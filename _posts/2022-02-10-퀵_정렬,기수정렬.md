---
title : "[2021 인공지능전문가 교육과정 복습] 퀵 정렬, 기수 정렬 알고리듬"
excerpt : "부산대학교 인공지능전문가 교육과정 - 데이터사이언스:데이터 구조 수업 복습 후 정리"

categories : 
- Data Science
- python
- data structure

tags : 
- [data structure, computer science, python, study, data science]

toc : true 
toc_sticky : true 
use_math : true

date : 2022-02-10
last_modified_at : 2022-02-10

---

# 퀵 정렬(Quick Sort)

피벗(기준) 정렬.

## 정의 

피벗값을 기준삼아. 피벗 왼쪽에는 피벗보다 작은 값들, 오른쪽에는 큰 값들 오도록 정렬하는 알고리듬.

## 특징 

- 피벗값은 아무거나 잡아도 되나, 기왕이면 중앙값 잡는 게 좋다. 그 값 중심으로 왼쪽 작은 부분과 오른쪽 큰 부분이 균등하게 나눠지도록 하기 위해서다. 양쪽이 균등하게 나눠 질 수록 정렬 수행 시간 빨라진다. 
- 일반적으로 가장 빠른 정렬 알고리듬이다. 
- 합병정렬이 정렬 과정에서 전체를 균등분할 했다면, 퀵 정렬은 대부분 경우 비균등분할한다. 

## 메커니즘 

1. 피벗값 잡는다. 
2. i, j 잡고 각각 오른쪽, 왼쪽 방향 이동하다가 각각 피벗보다 큰 값, 피벗보다 작은 값 만나면 멈춘다. 
3. i, j 위치의 값 서로 교환한다. 
4. 2~3 과정 반복. i = j(둘이 만나는 경우) 또는 j < i(둘이 교차한 경우) 되면서 멈춘 경우 반복도 멈춘다. 
5. ### 피벗 왼쪽에는 피벗보다 작은 값만, 오른쪽에는 큰 값만 있어야 한다. 이 원칙에 기반해서 i, j 위치 값을 피벗과 비교한다. i, j 위치 값 중 원칙 어긋나는 값을 피벗과 교환한다. 이후 피벗 위치는 그 값의 최종위치다. 더 이상 정렬하지 않는다.
6. 피벗 기준 왼쪽과 오른쪽 부분리스트에서 1~5 과정을 재귀호출 함으로써 과정 반복한다. 매 재귀호출 마다 피벗값들이 최종위치에 놓여지면서 정렬된다. 

## 예시 - 1 

## 가장 왼쪽 레코드를 피벗(pivot)으로 잡는 경우 

<img width="371" alt="Screen Shot 2022-02-10 at 20 10 45" src="https://user-images.githubusercontent.com/83487073/153395352-965fae98-859c-4b06-abd6-e6f0ac15c2f0.png">

## 예시 - 2

## 중간 레코드를 피벗으로 잡는 경우 1

<img width="353" alt="Screen Shot 2022-02-10 at 20 12 57" src="https://user-images.githubusercontent.com/83487073/153395698-8b41fb2c-a7f5-4b5d-a81c-0b784bcadf0d.png">

## 예시 - 3

## 중간 레코드를 피벗으로 잡는 경우 2

<img width="366" alt="Screen Shot 2022-02-10 at 20 13 37" src="https://user-images.githubusercontent.com/83487073/153395829-c9e0575d-af4f-41c4-8d2e-59bb516be310.png">

## 예시 - 4

## 가장 오른쪽 레코드를 피벗으로 잡는 경우 

<img width="373" alt="Screen Shot 2022-02-10 at 20 14 18" src="https://user-images.githubusercontent.com/83487073/153395948-1b7ce496-ab65-45ab-b119-c3addef6d84b.png">

---

# 퀵 정렬 성능 

## 평균 경우: $O(N\log_{2}{N})$

## 최선 경우: 각 부분리스트가 균등분할 되는 경우 

이론상 가장 이상적 경우는 각 부분리스트가 모두 균등분할 되는 경우다. 

- 재귀호출 수: $\log_{2}{n}$

입력의 원소 개수를 $2^{k}$ 개 라고 가정하자. $n = 2^{k}$.

k가 3인 경우($n = 2^{3}$) 재귀호출 하면서 균등분할 한다고 했을 때. 

$2^{3} \Rightarrow 2^{2} \Rightarrow 2^{1} \Rightarrow 2^{0}$ 으로 총 $3$번 재귀호출 하게 된다. 

곧, 재귀호출 수 $= k$ 가 된다. 

$n = 2^{k} \Rightarrow k = \log_{2}{n}$ 이므로 재귀호출 수는 $\log_{2}{n}$ 이 된다. 

- 각 재귀호출에서 레코드 간 비교 횟수: $n$
- 이동횟수는 비교횟수에 비해 적어 무시가능

총 비교 횟수 $\Rightarrow n\log_{2}{n}$ 

### 따라서 

### 퀵 정렬 최선 경우 성능: $O(N\log_{2}{N})$

## 최악 경우: 극도로 불균등한 리스트로 분할되는 경우 

퀵 정렬은 리스트 분할이 불균등 할 수록 시간복잡도 증가한다. 

이미 정렬된 리스트 정렬의 예)

[ 1,2,3,4,5,6,7,8 ] 이라는 이미 정렬된 리스트가 있다고 하자. 

가장 왼쪽 원소를 피벗 삼아 퀵 정렬 한다. 

이 경우 매 순환호출 마다 리스트가 오른쪽으로 전부 몰려서 분할된다. 왼쪽 부분리스트는 아예 없다. 

- 총 비교횟수: $n+(n-1)+(n-2)+...+2+1 = \frac{n(n+1)}{2}$
- 이미 정렬되어 있기 때문에 이동은 없다. 

### 따라서 

### 퀵 정렬 최악 경우 성능: $O(N^{2})$

---

# 퀵 정렬 구현 

## 퀵 정렬 정의(1) - pivot을 가운데 값으로 잡는 경우 

```python 
# pivot이 가운데 있는 경우 정의 

def partition(a, low, high) : 
    i = low 
    j = high 
    pivot = (high + low) // 2

    while True : 
        while (i < high) and (a[i] < a[pivot]) : 
            i += 1
        while (j > low) and (a[j] > a[pivot]) : 
            j -= 1
        if j <= i : break # 계속 가다가 멈춘 사유가 j <= i 이면 break.
        if (i == pivot) : 
            a[i], a[j] = a[j], a[i]
            pivot = j # pivot은 포인터에 불과 
            i += 1 ; j -= 1
        elif (j == pivot) : 
            a[i], a[j] = a[j], a[i]
            pivot = i
            i += 1 ; j -= 1
        else : 
            a[i], a[j] = a[j], a[i]
            i += 1 ; j -= 1
    
    if (a[j] <= a[pivot]) and (j >= pivot) : 
        a[pivot], a[j] = a[j], a[pivot]
        return j
    elif (a[i] >= a[pivot]) and (i <= pivot) : 
        a[pivot], a[i] = a[i], a[pivot]
        return i

# 퀵 정렬 

def qsort(a, low, high) : 
    if (low < high) : 
        pivot = partition(a, low, high)
        qsort(a, low, pivot-1)
        qsort(a, pivot+1, high)
```

## 알고리듬 테스트 

### (1)
```python
# 정렬 알고리듬 테스트 

a = [54, 88, 77, 26, 93, 17, 49, 10, 17, 77, 11, 31, 22, 44, 17, 20]

print(f'정렬 전:{a}')
qsort(a, 0, len(a)-1)
print(f'정렬 후:{a}')
```
정렬 전:[54, 88, 77, 26, 93, 17, 49, 10, 17, 77, 11, 31, 22, 44, 17, 20]

정렬 후:[10, 11, 17, 17, 17, 20, 22, 26, 31, 44, 49, 54, 77, 77, 88, 93]

### (2)

```python 
# 정렬 알고리듬 테스트 

random_list = list(np.random.randint(0,100,20))

print(f'정렬 전:{random_list}')
qsort(random_list, 0, len(random_list)-1)
print(f'퀵 정렬 후:{random_list}')
```
정렬 전:[5, 83, 59, 31, 86, 89, 25, 91, 41, 15, 77, 6, 55, 55, 46, 59, 91, 40, 50, 46]

퀵 정렬 후:[5, 6, 15, 25, 31, 40, 41, 46, 46, 50, 55, 55, 59, 59, 77, 83, 86, 89, 91, 91]

### (3)

```python 
# 정렬 알고리듬 테스트 

random_list = list(np.random.randint(0,1000,20))

print(f'정렬 전:{random_list}')
qsort(random_list, 0, len(random_list)-1)
print(f'퀵 정렬 후:{random_list}')
```
정렬 전:[831, 388, 62, 442, 111, 668, 838, 7, 869, 445, 635, 793, 169, 843, 586, 405, 346, 892, 665, 950]

퀵 정렬 후:[7, 62, 111, 169, 346, 388, 405, 442, 445, 586, 635, 665, 668, 793, 831, 838, 843, 869, 892, 950]

## 퀵 정렬 정의(2) - 가장 왼쪽 레코드가 pivot이 되는 경우

```python 
# 가장 왼쪽이 pivot이 되는 경우 정의

def partition_pl(a, pivot, high) : 
    i = pivot + 1
    j = high 

    while True : 
        while (i < high) and (a[i] < a[pivot]) : 
            i += 1
        while (j > pivot) and (a[j] > a[pivot]) : 
            j -= 1
        if j <= i : break # i, j 만났거나 i, j 교차해서 멈춘 경우
        a[i], a[j] = a[j], a[i]
        i += 1 ; j -= 1 
    # break 로 loop 깨진 경우 
    a[pivot], a[j] = a[j], a[pivot]
    return j # pivot 위치 반환 

# 퀵 정렬 정의
def qsort_pl(a, low, high) : 
    if low < high : 
        pivot = partition_pl(a, low, high)
        qsort_pl(a, low, pivot-1)
        qsort_pl(a, pivot+1, high)
```

## 알고리듬 테스트 

```python 
# 테스트 - qsort_pl
randoms = np.random.randint(0, 1000, 20)

print(f'정렬 전:{randoms}')
qsort_pl(randoms, 0, len(randoms)-1)
print(f'정렬 후:{randoms}')
```

정렬 전:[468  69 341 122 406 909 912 904 327 811 448  80 379 333 960 478 652  48 913 386]

정렬 후:[ 48  69  80 122 327 333 341 379 386 406 448 468 478 652 811 904 909 912 913 960]

## 퀵 정렬 정의(3) - 가장 오른쪽 레코드가 pivot이 되는 경우

```python 
# 가장 오른쪽이 pivot이 되는 경우 정의 

def partition_pr(a, low, pivot) : 
    i = low 
    j = pivot - 1

    while True : 
        while (i < pivot) and (a[i] < a[pivot]) : 
            i += 1 
        while (j > low) and (a[j] > a[pivot]) : 
            j -= 1
        if (j <= i) : break 
        a[i], a[j] = a[j], a[i]
        i += 1 ; j-= 1
    a[pivot], a[i] = a[i], a[pivot]
    return i # pivot 위치 반환 

# 퀵 정렬 정의
def qsort_pr(a, low, high) : 
    if low < high : 
        pivot = partition_pr(a, low, high)
        qsort_pr(a, low, pivot-1)
        qsort_pr(a, pivot+1, high)
```

## 알고리듬 테스트 

```python 
# 테스트 - qsort_pr 

randoms = np.random.randint(5, 100, 20)

print(f'정렬 전:{randoms}')
qsort_pr(randoms, 0, len(randoms)-1)
print(f'정렬 후:{randoms}')
```

정렬 전:[78 78  8 38 33 31 12 71 95 78 99 54 29 65 65 15 28 33 10 58]

정렬 후:[ 8 10 12 15 28 29 31 33 33 38 54 58 65 65 71 78 78 78 95 99]

---

# 정렬 알고리듬 별 비교 

시간복잡도, 안정성, 추가메모리 필요 여부 비교 

<img width="916" alt="Screen Shot 2022-02-10 at 22 22 07" src="https://user-images.githubusercontent.com/83487073/153416753-b0b4f6a1-bfa1-4edc-b9f6-a270a8f37b71.png">

---

# 기수 정렬(Radix Sort)

